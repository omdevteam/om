# This file is part of OM.
#
# OM is free software: you can redistribute it and/or modify it under the terms of
# the GNU General Public License as published by the Free Software Foundation, either
# version 3 of the License, or (at your option) any later version.
#
# OM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with OM.
# If not, see <http://www.gnu.org/licenses/>.
#
# Copyright 2020 -2023 SLAC National Accelerator Laboratory
#
# Based on OnDA - Copyright 2014-2019 Deutsches Elektronen-Synchrotron DESY,
# a research centre of the Helmholtz Association.
"""
TODO
"""

from typing import Any, Dict, Tuple, Union

import numpy
from numpy.typing import NDArray

from om.algorithms.xes import EnergySpectrumRetrieval


class XesAnalysisAndPlots:
    """
    TODO
    """

    def __init__(self, *, parameters: Dict[str, Any], time_resolved: bool) -> None:
        """
        Data analysis and plot generation for x-ray emission spectroscopy data.

        This class stores all the information required to compute energy spectra from
        detector data frames, and analyze them. Additionally, the class stores all the
        information needed to generate and update plots that summarize the state of an
        x-ray emission spectroscopy experiment. specifically.

        After the class has been initialized, data event information can be added, and
        the updated plots can be retrieved and sent to external programs for
        visualization.

        Arguments:

            parameters: An object storing OM's configuration parameters. The set of
                OM's configuration parameters must include a parameter group called
                `xes` with the entries required to fine-tune the spectrum calculation.
                Please refer to the documentation of the
                [EnergySpectrumRetrieval][om.algorithms.xes.EnergySpectrumRetrieval]
                algorithm).
        """
        self._time_resolved: bool = time_resolved

        self._spectra_cumulative_sum: Union[
            NDArray[numpy.float_], NDArray[numpy.int_], None
        ] = None
        self._spectra_cumulative_sum_smoothed: Union[NDArray[numpy.float_], None] = None

        self._cumulative_2d: Union[
            NDArray[numpy.float_], NDArray[numpy.int_], None
        ] = None
        self._cumulative_2d_pumped: Union[
            NDArray[numpy.float_], NDArray[numpy.int_], None
        ] = None
        self._cumulative_2d_dark: Union[
            NDArray[numpy.float_], NDArray[numpy.int_], None
        ] = None

        self._num_events_pumped: int = 0
        self._num_events_dark: int = 0
        self._num_events: int = 0

        self._energy_spectrum_retrieval = EnergySpectrumRetrieval(parameters=parameters)

    def update_plots(
        self,
        *,
        detector_data: Union[NDArray[numpy.float_], NDArray[numpy.int_]],
        optical_laser_active: bool,
    ) -> Tuple[
        Union[NDArray[numpy.float_], NDArray[numpy.int_], None],
        Union[NDArray[numpy.float_], None],
        Union[NDArray[numpy.float_], NDArray[numpy.int_], None],
        Union[NDArray[numpy.float_], None],
        Union[NDArray[numpy.float_], None],
        Union[NDArray[numpy.float_], None],
    ]:
        """
        Updates and recovers the x-ray emission spectroscopy data plots.

        This function uses the provided information to update all the x-ray emission
        spectroscopy data plots generated by this class. The function assumes that all
        the provided information refers to the same data event.

        After updating the data plots, the function returns all the information needed
        to display them in a graphical interface, in the format of a tuple containing
        the following entries:

        * The cumulative sum of all observed energy spectra.

        * The cumulative sum of the smoothed versions of all observed energy spectra.

        * The cumulative sum of all observed data frames.

        * For pump-probe experiments, the cumulative sum of all observed energy spectra
          for events with an active optical laser. Otherwise, just the value None.

        * For pump-probe experiments, the cumulative sum of all observed energy spectra
          for events without an active optical laser. Otherwise, just the value None.

        * For pump-probe experiments, the the difference between the cumulative sum of
          all observed energy spectra observed for events with and without an active
          optical laser. Otherwise, just the value None.

        Arguments:

            detector_data: The detector data frame to analyze and to use for updating
                the plots.

            optical_laser_active: Whether the optical laser is active or not in the
                data event to which the provided information is associated. This
                argument is only relevant for pump-probe experiments.

        Returns:

                The information needed to display the plots in a graphical interface.
        """
        self._num_events += 1

        if self._time_resolved:
            if optical_laser_active:
                self._num_events_pumped += 1
            else:
                self._num_events_dark += 1

        if self._cumulative_2d is None:
            self._cumulative_2d = detector_data
        else:
            self._cumulative_2d += (
                (detector_data - self._cumulative_2d * 1.0) / self._num_events * 1.0
            )

        # Calculate normalized spectrum from cumulative 2D images.
        cumulative_xes: Dict[
            str, NDArray[numpy.float_]
        ] = self._energy_spectrum_retrieval.calculate_spectrum(data=self._cumulative_2d)

        self._spectra_cumulative_sum = cumulative_xes["spectrum"]
        self._spectra_cumulative_sum_smoothed = cumulative_xes["spectrum_smoothed"]

        spectra_cumulative_sum_pumped: Union[NDArray[numpy.float_], None] = None
        spectra_cumulative_sum_dark: Union[NDArray[numpy.float_], None] = None
        spectra_cumulative_sum_difference: Union[NDArray[numpy.float_], None] = None

        if numpy.mean(numpy.abs(self._spectra_cumulative_sum)) > 0:
            self._spectra_cumulative_sum /= numpy.mean(
                numpy.abs(self._spectra_cumulative_sum)
            )
        if numpy.mean(numpy.abs(self._spectra_cumulative_sum_smoothed)) > 0:
            self._spectra_cumulative_sum_smoothed /= numpy.mean(
                numpy.abs(self._spectra_cumulative_sum_smoothed)
            )

        if self._time_resolved:
            # Sum the spectra for pumped (optical_laser_active) and dark
            if self._cumulative_2d_pumped is None:
                self._cumulative_2d_pumped = detector_data * 0
            if self._cumulative_2d_dark is None:
                self._cumulative_2d_dark = detector_data * 0

            # Need to calculate a running average
            if optical_laser_active:
                self._cumulative_2d_pumped += (
                    (detector_data - self._cumulative_2d_pumped * 1.0)
                    / self._num_events_pumped
                    * 1.0
                )
            else:
                self._cumulative_2d_dark += (
                    (detector_data - self._cumulative_2d_dark * 1.0)
                    / self._num_events_dark
                    * 1.0
                )

            # Calculate spectrum from cumulative 2D images
            cumulative_xes_pumped: Dict[
                str, NDArray[numpy.float_]
            ] = self._energy_spectrum_retrieval.calculate_spectrum(
                data=self._cumulative_2d_pumped
            )
            spectra_cumulative_sum_pumped = cumulative_xes_pumped["spectrum"]

            # calculate spectrum from cumulative 2D images
            cumulative_xes_dark: Dict[
                str, NDArray[numpy.float_]
            ] = self._energy_spectrum_retrieval.calculate_spectrum(
                data=self._cumulative_2d_dark
            )
            spectra_cumulative_sum_dark = cumulative_xes_dark["spectrum"]

            # normalize spectra
            if numpy.mean(numpy.abs(spectra_cumulative_sum_pumped)) > 0:
                spectra_cumulative_sum_pumped /= numpy.mean(
                    numpy.abs(spectra_cumulative_sum_pumped)
                )
            if numpy.mean(numpy.abs(spectra_cumulative_sum_dark)) > 0:
                spectra_cumulative_sum_dark /= numpy.mean(
                    numpy.abs(spectra_cumulative_sum_dark)
                )

            spectra_cumulative_sum_difference = (
                spectra_cumulative_sum_pumped - spectra_cumulative_sum_dark
            )

        return (
            self._spectra_cumulative_sum,
            self._spectra_cumulative_sum_smoothed,
            self._cumulative_2d,
            spectra_cumulative_sum_pumped,
            spectra_cumulative_sum_dark,
            spectra_cumulative_sum_difference,
        )
